# План реализации программы ChatList

## Этап 1: Настройка проекта и базы данных

### 1.1 Инициализация проекта
- [ ] Создать структуру директорий проекта
- [ ] Создать файл `requirements.txt` с зависимостями:
  - PyQt5
  - requests или httpx
  - python-dotenv (для работы с .env)
- [ ] Создать файл `.env.example` с примерами переменных окружения
- [ ] Создать файл `.gitignore` (исключить .env, __pycache__, *.db)

### 1.2 Создание модуля базы данных (db.py)
- [ ] Реализовать класс `Database` для работы с SQLite
- [ ] Создать метод `init_db()` для инициализации БД и создания таблиц:
  - `prompts` (id, date, prompt, tags)
  - `models` (id, name, api_url, api_id, is_active)
  - `results` (id, prompt_id, model_id, response, selected, created_at)
  - `settings` (id, key, value)
- [ ] Реализовать методы CRUD для каждой таблицы:
  - `create_prompt()`, `get_prompts()`, `update_prompt()`, `delete_prompt()`
  - `create_model()`, `get_models()`, `get_active_models()`, `update_model()`, `delete_model()`
  - `save_results()`, `get_results()`, `delete_result()`
  - `get_setting()`, `set_setting()`
- [ ] Добавить методы поиска и сортировки для всех таблиц

## Этап 2: Работа с API нейросетей

### 2.1 Создание модуля network.py
- [ ] Реализовать базовый класс `APIClient` для работы с API
- [ ] Создать классы-наследники для разных типов моделей:
  - `OpenAIClient` (OpenAI API)
  - `DeepSeekClient` (DeepSeek API)
  - `GroqClient` (Groq API)
  - Базовый класс для расширяемости
- [ ] Реализовать метод `send_request(prompt: str) -> str` для каждого клиента
- [ ] Добавить обработку ошибок и таймаутов
- [ ] Реализовать асинхронную отправку запросов (опционально, для ускорения)

### 2.2 Интеграция с моделями
- [ ] Создать модуль `models.py` для работы с конфигурацией моделей
- [ ] Реализовать класс `ModelManager`:
  - Загрузка списка моделей из БД
  - Создание соответствующих API-клиентов
  - Управление активными моделями
- [ ] Реализовать метод `send_to_all_models(prompt: str) -> List[Result]`
- [ ] Добавить логирование запросов и ответов

## Этап 3: Основной интерфейс (main.py)

### 3.1 Создание главного окна
- [ ] Расширить класс `MainWindow` из базового шаблона
- [ ] Создать layout с основными секциями:
  - Панель ввода промта
  - Список сохраненных промтов
  - Таблица результатов
  - Панель управления

### 3.2 Панель ввода промта
- [ ] Добавить текстовое поле (QTextEdit) для ввода промта
- [ ] Добавить поле для тегов (QLineEdit)
- [ ] Добавить кнопку "Отправить запрос"
- [ ] Добавить выпадающий список (QComboBox) для выбора сохраненного промта
- [ ] Реализовать логику загрузки сохраненных промтов из БД

### 3.3 Таблица результатов
- [ ] Создать QTableWidget для отображения результатов
- [ ] Настроить колонки:
  - Чекбокс (selected)
  - Название модели
  - Текст ответа
- [ ] Реализовать временное хранение результатов в памяти (список словарей)
- [ ] Добавить обработчик изменения чекбоксов
- [ ] Реализовать авто-обновление таблицы при получении новых ответов

### 3.4 Панель управления
- [ ] Добавить кнопку "Сохранить выбранные"
- [ ] Добавить кнопку "Очистить результаты"
- [ ] Добавить кнопку "Новый запрос"
- [ ] Реализовать обработчики для всех кнопок

### 3.5 Логика работы с запросами
- [ ] Реализовать метод `send_prompt()`:
  - Получение активных моделей из БД
  - Отправка промта во все модели через ModelManager
  - Обновление временной таблицы результатов
- [ ] Реализовать метод `save_selected_results()`:
  - Сохранение промта в таблицу prompts (если новый)
  - Сохранение выбранных результатов в таблицу results
  - Очистка временной таблицы
- [ ] Реализовать метод `clear_results()`:
  - Очистка временной таблицы
  - Обновление UI

## Этап 4: Управление моделями

### 4.1 Окно управления моделями
- [ ] Создать диалоговое окно `ModelSettingsDialog`
- [ ] Добавить таблицу со списком всех моделей
- [ ] Реализовать функции:
  - Добавление новой модели
  - Редактирование существующей модели
  - Удаление модели
  - Включение/отключение модели (чекбокс is_active)
- [ ] Добавить валидацию полей (api_url, api_id)

### 4.2 Интеграция с главным окном
- [ ] Добавить пункт меню "Настройки моделей"
- [ ] Подключить диалог к главному окну
- [ ] Реализовать обновление списка моделей после изменений

## Этап 5: Дополнительные функции

### 5.1 Поиск и сортировка
- [ ] Добавить поиск в таблице промтов (QLineEdit с фильтром)
- [ ] Добавить поиск в таблице результатов
- [ ] Реализовать сортировку по колонкам во всех таблицах
- [ ] Добавить фильтр по тегам для промтов

### 5.2 Экспорт данных
- [ ] Реализовать экспорт результатов в Markdown:
  - Форматирование с заголовками
  - Сохранение структуры (модель, ответ)
- [ ] Реализовать экспорт результатов в JSON:
  - Структурированный формат
  - Включение метаданных (дата, промт, теги)
- [ ] Добавить кнопку "Экспорт" в интерфейс
- [ ] Создать диалог выбора формата и пути сохранения

### 5.3 Логирование
- [ ] Настроить модуль logging
- [ ] Добавить логирование:
  - Запросов к API (успешных и неудачных)
  - Ошибок работы с БД
  - Действий пользователя
- [ ] Создать окно просмотра логов (опционально)

### 5.4 Настройки приложения
- [ ] Реализовать сохранение настроек в таблицу settings:
  - Путь для экспорта по умолчанию
  - Таймаут запросов
  - Размер окна и позиция
- [ ] Создать окно настроек
- [ ] Реализовать загрузку настроек при запуске

## Этап 6: AI-ассистент для улучшения промтов

### 6.1 Создание модуля для улучшения промтов (prompt_improver.py)
- [ ] Создать модуль `prompt_improver.py` для работы с улучшением промтов
- [ ] Реализовать класс `PromptImprover`:
  - Принимает исходный промт и модель для улучшения
  - Использует существующий OpenRouter клиент или другую указанную модель
  - Формирует специальный промт для улучшения (system prompt)
- [ ] Реализовать метод `improve_prompt(prompt: str, model_name: str) -> Dict`:
  - Отправляет запрос к выбранной модели с инструкцией улучшить промт
  - Возвращает структурированный ответ с улучшенными вариантами
- [ ] Реализовать метод `get_improved_version(prompt: str) -> str`:
  - Получает улучшенную версию промта
- [ ] Реализовать метод `get_alternatives(prompt: str) -> List[str]`:
  - Получает 2-3 альтернативных варианта переформулировки
- [ ] Реализовать метод `adapt_for_model_type(prompt: str, model_type: str) -> str`:
  - Адаптирует промт под разные типы моделей (код, анализ, креатив)
  - model_type может быть: "code", "analysis", "creative", "general"

### 6.2 Создание диалога улучшения промтов (prompt_improver_dialog.py)
- [ ] Создать диалоговое окно `PromptImproverDialog`
- [ ] Реализовать интерфейс диалога:
  - Поле для отображения исходного промта (read-only)
  - Выбор модели для улучшения (QComboBox с активными моделями)
  - Кнопка "Улучшить промт"
  - Область для отображения результатов:
    - Вкладки или разделы для:
      - Улучшенная версия
      - Альтернативные варианты (2-3 варианта)
      - Адаптация под типы моделей (опционально)
- [ ] Реализовать отображение результатов:
  - Улучшенная версия промта в текстовом поле
  - Список альтернативных вариантов с кнопками "Использовать"
  - Возможность просмотра адаптированных версий
- [ ] Добавить кнопки действий:
  - "Использовать улучшенную версию" - подставляет в поле ввода главного окна
  - "Использовать вариант N" - подставляет выбранный альтернативный вариант
  - "Копировать в буфер обмена" для каждого варианта
  - "Отмена" - закрывает диалог без изменений

### 6.3 Интеграция в главное окно
- [ ] Добавить кнопку "Улучшить промт" рядом с полем ввода промта
- [ ] Реализовать обработчик кнопки `on_improve_prompt()`:
  - Получает текущий текст из поля ввода
  - Открывает диалог `PromptImproverDialog`
  - Передает текущий промт в диалог
- [ ] Реализовать метод `apply_improved_prompt(prompt_text: str)`:
  - Подставляет выбранный улучшенный промт в поле ввода
  - Обновляет UI главного окна
- [ ] Добавить возможность вызова улучшения из контекстного меню поля ввода

### 6.4 Системные промпты для улучшения
- [ ] Создать шаблоны системных промптов для разных типов улучшения:
  - Базовое улучшение (четкость, конкретность)
  - Переформулировка (альтернативные варианты)
  - Адаптация под код (технические детали, примеры)
  - Адаптация под анализ (структурированность, критерии)
  - Адаптация под креатив (образность, метафоры)
- [ ] Реализовать метод формирования системного промпта:
  - Выбор подходящего шаблона
  - Подстановка исходного промта
  - Формирование структурированного запроса

### 6.5 Парсинг ответов от модели
- [ ] Реализовать парсинг ответа модели:
  - Распознавание улучшенной версии промта
  - Извлечение альтернативных вариантов (нумерованный список)
  - Обработка различных форматов ответов
- [ ] Добавить валидацию улучшенных промтов:
  - Проверка на пустоту
  - Проверка минимальной длины
  - Проверка структуры ответа
- [ ] Реализовать fallback на случай некорректного ответа:
  - Отображение исходного промта, если улучшение не удалось
  - Сообщение об ошибке пользователю

### 6.6 Обработка ошибок и оптимизация
- [ ] Добавить обработку ошибок при улучшении:
  - Ошибки подключения к API
  - Таймауты запросов
  - Некорректные ответы от модели
- [ ] Реализовать индикатор загрузки во время обработки
- [ ] Добавить кеширование результатов улучшения (опционально):
  - Сохранение улучшенных версий для часто используемых промтов
  - Избежание повторных запросов для одинаковых промтов
- [ ] Реализовать логирование операций улучшения

### 6.7 Расширенные возможности (опционально)
- [ ] Добавить настройки улучшения промтов:
  - Выбор стиля улучшения (формальный, неформальный)
  - Предпочтения по длине промта (краткий, подробный)
  - Сохранение настроек в таблицу settings
- [ ] Реализовать историю улучшений:
  - Сохранение исходного и улучшенного промта
  - Возможность вернуться к предыдущим версиям
- [ ] Добавить сравнение вариантов:
  - Отображение всех вариантов рядом для сравнения
  - Подсветка различий между вариантами

## Этап 7: Тестирование и доработка

### 7.1 Тестирование функциональности
- [ ] Протестировать работу с БД (создание, чтение, обновление, удаление)
- [ ] Протестировать отправку запросов к разным API
- [ ] Протестировать сохранение и загрузку результатов
- [ ] Протестировать экспорт в разные форматы

### 7.2 Обработка ошибок
- [ ] Добавить обработку ошибок подключения к API
- [ ] Добавить обработку ошибок работы с БД
- [ ] Добавить информативные сообщения об ошибках пользователю
- [ ] Реализовать graceful degradation при недоступности некоторых моделей

### 7.3 Оптимизация и рефакторинг
- [ ] Оптимизировать работу с БД (индексы, запросы)
- [ ] Улучшить производительность UI (обновление таблиц)
- [ ] Рефакторинг кода (выделение общих функций)
- [ ] Добавить комментарии и docstrings

## Этап 8: Финальная подготовка

### 8.1 Документация
- [ ] Создать README.md с инструкциями по установке и использованию
- [ ] Добавить примеры использования
- [ ] Описать формат .env файла

### 8.2 Упаковка
- [ ] Создать скрипт для создания .exe (PyInstaller, опционально)
- [ ] Подготовить финальную версию requirements.txt
- [ ] Проверить работу на чистой системе

